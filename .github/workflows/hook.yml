name: Hook
on:
  push:
    branches:
      - master
  workflow_dispatch:
    inputs:
      arguments:
        description: 'Client JSON Payload'
        type: string
        default: '{}'
        required: true

jobs:
  job1:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2

      - name: Run some tests
        run: |
          echo "Running job1"
          exit 1  # Simulate failure

      - name: Set job status
        if: failure()  # This will be true if the job fails
        run: echo "sdfsd"
      
      - name: Set success status
        if: success()  # This will be true if the job succeeds
        run: echo "asdfdsf"

  job2:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2

      - name: Run some tests
        run: |
          echo "Running job2"
      - name: Run some tests
        run: |
          echo "Running job2"
          #exit 1  # Simulate failure

  final_job:
    runs-on: ubuntu-latest
    if: always()
    needs: [job1, job2] # Add all jobs that this final job depends on
    steps:
      - name: Determine failed jobs
        run: |
          failed_jobs=()
          if [ "${{ needs.job1.result }}" == "failure" ]; then
            failed_jobs+=("job1")
          fi
          if [ "${{ needs.job2.result }}" == "failure" ]; then
            failed_jobs+=("job2")
          fi

          # Join the array into a single string separated by commas
          if [ ${#failed_jobs[@]} -eq 0 ]; then
            failed_jobs_str=""
          else
            failed_jobs_str=$(IFS=,; echo "${failed_jobs[*]}")
          fi

          # Export the failed jobs string to the environment
          echo "FAILED_JOBS=$failed_jobs_str" >> $GITHUB_ENV

      - name: Print failed jobs
        env:
          FAILED_JOBSS: ${{ env.FAILED_JOBS }}
        run: |
          echo $FAILED_JOBS
          
